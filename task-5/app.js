"use strict";

const log = console.log;

log(1 - "0" + 2); // Арифметические операторы '-' вызывает неявное преобразование к числовому типу (1 -'0' => 1 - 0 = 1), затем происходит арифметическая операция сложения чисел(1 + 2 = 3).

log(1 - "-0" + 2); // Арифметические операторы '-' вызывает неявное преобразование к числовому типу (1 -'-0' => 1 + 0 = 1), затем происходит арифметическая операция сложения чисел(1 + 2 = 3).

log(1 - "-0-" + "NaN"); // '-0-' JS не может преобразовать -0- к числу, в результате чего, эта математическая функция не сработает должным образом и нам вернется NaN (1 -'-0-' = NaN), затем NaN конкатенирует с 'NaN', оператор '+' с двумя операндами не вызывает неявное преобразование к числовому типу, если хотя бы один оператор является строкой(NaN + 'NaN' = NaNNaN).

log("b" + [NaN + "ba", "CC"] - {}); // Доступ к свойствам с возможностью вычисления выполняется слева направо, в данном случае конкатенация('b' + [NaN + 'ba', 'CC'] = 'bNaNba,CC'), затем JS не может преобразовать 'bNaNba,CC' к числу, в результате чего ('bNaNba,CC' - {} = NaN).

log([] + (() => {})); // Оператор '+' вызывает численное преобразование массива. Метод массива valueOf() вернёт сам массив, поэтому результат игнорируется, поскольку не является примитивом. Далее выполняется выражение ’’ + (() => {}) = '() => {}'.

log([] + (() => ({}))); // Оператор '+' вызывает численное преобразование массива. Метод массива valueOf() вернёт сам массив, поэтому результат игнорируется, поскольку не является примитивом. Далее выполняется выражение ’’ + (() => ({})) = '() => ({})'.

log([] + (() => ({}))()); // В данном примере функция создает объект и затем вызывается сама, пустой массив - это '' , а конкатенация '' + пустой объект - это '[object Object]'(Доступ к свойствам с возможностью вычисления выполняется слева направо)

log([] + (() => new Object(123))()); // В данном примере функция создает объект и затем вызывается сама, происходит преобразование конструктора в объект-обёртку, позволяющей нам работать с числовыми значениями (Number{123}), затем [] преобразуется в '' и происходит конкатенация => '' + Number {123} = '123' (Доступ к свойствам с возможностью вычисления выполняется слева направо)

log({} + (() => new Object(123))()); // Cтандартным строковым представлением объекта является строка "[object Object]", поэтому как и в примере выше "[object Object]" + Number{123} => "[object Object]123"(конкатенация)

log((() => new Object(123))() + {}); // Как и в примере выше, только изменено расположение => Number{123} + "[object Object]"=> "123[object Object]"(конкатенация)

log({}.valueOf() + 1); // ValueOf есть у любых объектов. Но он ничего не делает, просто возвращает сам объект, а потому игнорируется. Поэтому {} - это '[object Object]' => '[object Object]' + 1 = '[object Object]1'(конкатенация)

log({} + 2); // {} - это '[object Object]' => '[object Object]' + 2 = '[object Object]2'(конкатенация)

log(typeof {}.valueOf() + 2); // typeof({}) => 'object', 'object'.valueOf() возвращает примитивное значение 'object' => 'object' + 2 = 'object2'(конкатенация)

log(+{}); // Унарный оператор '+' не может преобразовать {} в число, поэтому NaN.

log(+{} + []); // Унарный оператор '+' не может преобразовать {} в число, поэтому NaN, а [] - это '' (пустая строка) => NaN + '' = 'NaN' (конкатенация)

log(+[]); // [] - это '', происходит неявное преобразование к числовому типу => 0 ('унарный оператор '+', работает как и Number(преобразует в число))

log(+[] + {}); // [] - это '', происходит неявное преобразование к числовому типу => 0, а {} - это '[object Object]', поэтому 0 + '[object Object]' = '0[object Object]' (конкатенация)

log(+[10, 1] + {}); // Аргументы не может быть преобразованы в число(аргумент 10 и 1), поэтому +[10,1] возвращается NaN => NaN + '[object Object]' = 'NaN[object Object]' (конкатенация)

log({} + [10]); // {} - это '[object Object]', в данном случае унарный оператор + применяется к [10], а  +[10] = 10 => '[object Object]' + 10 = '[object Object]10' (конкатенация)

log(0 == null); // при нестрогом равенстве null равен только себе и undefined (правило языка JS) => true

log(undefined == null); // при нестрогом равенстве null равен только себе и undefined (правило языка JS) => true

log(1 == {}); // {} - это '[object Object]', поэтому false, т.к '[object Object]' != 1, и как-бы {} в априори не равен 1

log({} == 1); // {} - js воспринимает {}, как функцию,если он находится первым, поэтому false

log(({}) == 1); // {} - это '[object Object]', либо функция, поэтому false, т.к '[object Object]'!= 1, как и в первом случае

log({ toString: () => "12" } == 12); // Метод toString преобразует объект в примитив и вернет '12', а при нестрогом равенстве '12' == 12 true



//task - 1
let getLengthWords = (words) => {
  let emptyArr = [];
  let splitWords = words.split(" ");
  for (let letter of splitWords) {
    emptyArr.push(`${letter} ${letter.length}`);
  }
  return emptyArr;
};

console.log(getLengthWords("hello worldd"));





// task-2
function stateK(){
 let nextIndex=0;
 let cashe={};
 return function (arg){
  if(cashe[arg]>=0) {
   return cashe[arg]
  }
  else{
    cashe[arg]=nextIndex;
    nextIndex+=1;
   return cashe[arg];
  }
 }
}
let state=stateK();

let wordPattern = (str) =>{
let UpperCaseStr = str.toUpperCase()
let ans=UpperCaseStr
 .split("")
 .map(item=>{
   return state(item)
})
 .join(".")


 return ans
}
log(wordPattern('Hippopotomonstrosesquippedaliophobia'))


















